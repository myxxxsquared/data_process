#from .reader import data_loader  # <- for raw data loading
#from .util import *              # <- for data_augmentation
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('data_set', type=str, help='appoint a dataset to crunch')
parser.add_argument('start', type=int, help='starting point of the cruncher')
parser.add_argument('end', type=int, help='end point of the cruncher')
parser.add_argument('tf_record_path', type=str, help='appoint a path to store')
args = parser.parse_args()

class data_churn(object):
    def __init__(self,*args,**kw):
        """
        initialize an instance
        :param kw: 'data_set': str, 'SynthText', 'totaltext', etc.
                     'start_point','end_point':int, indicating the starting point for the crunching process
        """
        pass

    def _loader_initialization(self):
        """
        initialize self with a data list and loader, the loader should be a generator and
        yields the following format:
        {'img_name':str,   original_name
        'img':np.uint8,
        'contour':List[the contour of each text instance],
        'type': 'char' or 'tl',
        'flag':if this is synthetext or not}
        for the contour of TI, it should be List[cnt] where x,y are float(cnt)
        for the contour of char_list, it should be List[List(cnt)] List(p1,p2,p3,p4)- list of char
        :return:
        """
        #self._data_loader=data_loader(self.data_set,self.start_point,self.end_point)
        pass

    def _data_augmentation(self,*args,**kw):
        """
        generator
        :param kw:

        {'img_name':str,
        'img':np.uint8,
        'contour':List[the contour of each text instance]}

        :return: yielding all augmented data one by one in order

        using function from .util(to be determined)

        """
        pass

    def _data_labeling(self, *args, **kw):
        """
        taking input of the given format:
        {'img_name':str,   original_name
        'img':np.uint8,
        'contour':List[the contour of each text instance],
        'type': 'char' or 'tl'}

        return the labelled data instance:
        {'img_name':str,   original_name
        'img':np.uint8,
        'maps':[TR, 0/1 boolmap, 512*512,
                TCL, 0/1 boolmap, 512*512
                radius, float
                cos(theta), float
                sin(theta), float
                curvature, float
                ]
        }

        :param args:
        :param kw:
        :return:
        """
        pass

    def _data_generator_wrapper(self):
        """
        generator
        this function should work only as a wrapper and data label for the raw data generation.
        for synthtext: it returns what self.data_loader yields,
        for others: yields all DataAugmentation results one by one for each return generated by self.data_loader

        this function takes no params
        :return:
        """
        pass

    def data_to_tfrecord(self,tf_record_path):
        """
        this function uses all functions defined above to convert the data into tf_record located at tf_record_path
        :param tf_record_path:
        :return:
        """
        pass

if __name__=='__main__':
    #implement the main function for call data labeling conversion
    a=data_churn()## params
    a.data_to_tfrecord(args.tf_record_path)
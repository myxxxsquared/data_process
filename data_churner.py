#from .reader import data_loader  # <- for raw data loading
#from .util import *              # <- for data_augmentation
from .utils import get_maps
import argparse
import cv2
import numpy as np

parser = argparse.ArgumentParser()
parser.add_argument('data_set', type=str, help='appoint a dataset to crunch')
parser.add_argument('start', type=int, help='starting point of the cruncher')
parser.add_argument('end', type=int, help='end point of the cruncher')
parser.add_argument('tf_record_path', type=str, help='appoint a path to store')
args = parser.parse_args()

class data_churn(object):
    def __init__(self, thickness=0.15, neighbor=3.0, crop_skel=1.0, *args,**kw):
        """
        initialize an instance
        :param kw: 'data_set': str, 'SynthText', 'totaltext', etc.
                     'start_point','end_point':int, indicating the starting point for the crunching process
               thickness: the thickness of the text center line
               neighbor: the range used for fit the theta
               crop_skel: the length for cropping the text center line (skeleton)
        """
        self.thickness = thickness
        self.neighbor = neighbor
        self.crop_skel =crop_skel
        pass

    def _loader_initialization(self):
        """
        initialize self with a data list and loader, the loader should be a generator and
        yields the following format:
        {'img_name':str,   original_name
        'img':np.uint8,
        'contour':List[the contour of each text instance],
        'type': 'char' or 'tl',
        'flag':if this is synthetext or not}
        for the contour of TI, it should be List[cnt] where x,y are float(cnt)
        for the contour of char_list, it should be List[List(cnt)] List(p1,p2,p3,p4)- list of char
        :return:
        """
        #self._data_loader=data_loader(self.data_set,self.start_point,self.end_point)
        pass

    def _data_augmentation(self,*args,**kw):
        """
        generator
        :param kw:

        {'img_name':str,
        'img':np.uint8,
        'contour':List[the contour of each text instance]}

        :return: yielding all augmented data one by one in order

        using function from .util(to be determined)

        """
        pass

    def _data_labeling(self, img_name, img, cnts, is_text_cnts, left_top, right_bottom):
        """
        taking input of the given format:
        {'img_name':str,   original_name
        'img':np.uint8, raw_img, it can has arbitary size
        'contour':List[the contour of each text instance],
        'is_text_cnts': bool, ture for cnts of boxes,
                            false for cnts of char
                            important: if False, cnts = [char_cnts, text_cnts]
        'left_top': tuple (x, y), x is row, y is col, please be careful about the order,
        'right_bottom': tuple (x, y), x is row, y is col}


        return the labelled data instance:
        {'img_name':str,   original_name
        'img':np.uint8,
        'maps':[TR, 0/1 boolmap, 512*512,
                TCL, 0/1 boolmap, 512*512
                radius, float
                cos(theta), float
                sin(theta), float
                curvature, float
                ]
        }

        :param args:
        :param kw:
        :return:
        """

        skels_points, radius_dict, score_dict, cos_theta_dict, sin_theta_dict, mask_fills = \
            get_maps(img, cnts, is_text_cnts, self.thickness, self.neighbor, self.crop_skel)
        TR = mask_fills[0]
        for i in range(1, len(mask_fills)):
            TR = np.bitwise_and(TR, mask_fills[i])
        TCL = np.zeros(img.shape[:2], np.bool)
        for point, _ in score_dict.items():
            TCL[point[0], point[1]] = True
        radius = np.zeros(img.shape[:2], np.float32)
        for point, r in radius_dict.items():
            radius[point[0], point[1]] = r
        cos_theta = np.zeros(img.shape[:2], np.float32)
        for point, c_t in cos_theta_dict.items():
            cos_theta[point[0], point[1]] = c_t
        sin_theta = np.zeros(img.shape[:2], np.float32)
        for point, s_t in sin_theta_dict.items():
            sin_theta[point[0], point[1]] = s_t
        maps = [TR, TCL, radius, cos_theta, sin_theta]
        return img_name, img, maps


    def _data_generator_wrapper(self):
        """
        generator
        this function should work only as a wrapper and data label for the raw data generation.
        for synthtext: it returns what self.data_loader yields,
        for others: yields all DataAugmentation results one by one for each return generated by self.data_loader

        this function takes no params
        :return:
        """
        pass

    def data_to_tfrecord(self,tf_record_path):
        """
        this function uses all functions defined above to convert the data into tf_record located at tf_record_path
        :param tf_record_path:
        :return:
        """
        pass

if __name__=='__main__':
    #implement the main function for call data labeling conversion
    a=data_churn()## params
    a.data_to_tfrecord(args.tf_record_path)
    word_cnts = np.reshape(gt['wordBB'][0][0], (-1, 4, 2))
    char_cnts = np.reshape(gt['charBB'][0][0], (-1, 4, 2))
    img = np.zeros((1000,1000))
    cnts = [char_cnts, word_cnts]
    skels_points, radius_dict, score_dict, cos_theta_dict, sin_theta_dict, mask_fills = get_maps(img, cnts, False, 0.15, 2.0, 1.0)



